// Problem:
// Given a keypad as shown in the diagram, and an array arr[],
// your task is to list all possible words in any order which can be generated by pressing numbers from array.

// Examples:

// Input: arr[] = [2, 3]
// Output: [ad, ae, af, bd, be, bf, cd, ce, cf]
// Explanation: When we press 2, 3 total possible words are 3 x 3 = 9.

// Input: arr[] =[2]
// Output: [a, b, c]
// Explanation: When we press 2 total possible words are 3.

// Constraints:
// 1 ≤ arr.size() ≤ 9
// 1 ≤ arr[i] ≤ 9

// ✅ TC = O(4^n) (worst case: each digit has 4 letters)
// ✅ SC = O(n) (for the result array)
function possibleWords(arr) {
    // your code here
    let digitMap = { 2: "abc", 3: "def", 4: "ghi", 5: "jkl", 6:"mno", 
        7: "pqrs", 8: "tuv", 9: "wxyz"
    }
    
    let n = arr.length
    
    let res = []
    
    function backTrack(curr, i) {
        if (i === n) {
            res.push(curr);
            return;
        }
        
        const digit = arr[i].toString(); // Convert to string for consistent access
        const letters = digitMap[digit];
        
        if (!letters) {
            // Skip invalid digits (0, 1, *, #, etc.)
            backTrack(curr, i + 1);
        } else {
            for (let char of letters) {
                backTrack(curr + char, i + 1);
            }
        }
    }
    
    
    backTrack("", 0)
    return res
}

// Recursion call stack:
// For input: arr = [2, 3]
//
// backTrack("", 0)
// ├── backTrack("a", 1)           // i=0, digit=2, char='a'
// │   ├── backTrack("ad", 2)      // i=1, digit=3, char='d' → res.push("ad")
// │   ├── backTrack("ae", 2)      // i=1, digit=3, char='e' → res.push("ae")
// │   └── backTrack("af", 2)      // i=1, digit=3, char='f' → res.push("af")
// ├── backTrack("b", 1)           // i=0, digit=2, char='b'
// │   ├── backTrack("bd", 2)      // i=1, digit=3, char='d' → res.push("bd")
// │   ├── backTrack("be", 2)      // i=1, digit=3, char='e' → res.push("be")
// │   └── backTrack("bf", 2)      // i=1, digit=3, char='f' → res.push("bf")
// └── backTrack("c", 1)           // i=0, digit=2, char='c'
//     ├── backTrack("cd", 2)      // i=1, digit=3, char='d' → res.push("cd")
//     ├── backTrack("ce", 2)      // i=1, digit=3, char='e' → res.push("ce")
//     └── backTrack("cf", 2)      // i=1, digit=3, char='f' → res.push("cf")
//
// Result: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
//
// Each level represents a digit position (i)
// Each branch represents a character choice for that digit
// Base case: when i === n, we've formed a complete word

// ✅ Why TC = O(4^n)?
// For each digit position (i), we have up to 4 choices (digits 7,9 have 4 letters each)
// At each level of recursion, we make up to 4 recursive calls
// Total recursive calls = 4 × 4 × 4 × ... × 4 (n times) = 4^n
// 
// Example: arr = [7, 9, 7] (all have 4 letters)
// Level 0: 4 calls, Level 1: 4×4 calls, Level 2: 4×4×4 calls
// Total = 4³ = 64 recursive calls